"""
Nav2 Interface Module
Python interface for Nav2 navigation stack integration.
"""

import time
import logging
import threading
from enum import Enum
from typing import Optional, Tuple, Callable

logger = logging.getLogger(__name__)

try:
    import rclpy
    from rclpy.node import Node
    from rclpy.action import ActionClient
    from nav2_msgs.action import NavigateToPose
    from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
    from nav_msgs.msg import Path
    from std_msgs.msg import Bool
    from tf_transformations import quaternion_from_euler
    
    NAV2_AVAILABLE = True
except ImportError:
    NAV2_AVAILABLE = False
    logger.warning("Nav2 packages not available - using fallback mode")
    
    # Mock all classes for graceful degradation
    class Node:
        def __init__(self, name):
            self.name = name
        def get_clock(self):
            class Clock:
                def now(self):
                    class Time:
                        def to_msg(self): return None
                    return Time()
            return Clock()
        def create_subscription(self, *args, **kwargs):
            return None
    
    class ActionClient:
        def __init__(self, *args, **kwargs):
            pass
        def wait_for_server(self, timeout_sec=1.0):
            return False
    
    NavigateToPose = None
    Path = None
    PoseStamped = type('PoseStamped', (), {
        'header': type('Header', (), {'frame_id': '', 'stamp': None})(),
        'pose': type('Pose', (), {
            'position': type('Point', (), {'x': 0.0, 'y': 0.0, 'z': 0.0})(),
            'orientation': type('Quaternion', (), {'x': 0.0, 'y': 0.0, 'z': 0.0, 'w': 1.0})()
        })()
    })
    Pose = None
    Point = None
    Quaternion = None
    Bool = None
    
    def quaternion_from_euler(*args, **kwargs):
        return [0, 0, 0, 1]

# =============================================================================
# Navigation State
# =============================================================================

class NavigationState(Enum):
    """Nav2 navigation states."""
    IDLE = "idle"
    NAVIGATING = "navigating"
    SUCCEEDED = "succeeded"
    FAILED = "failed"
    CANCELLED = "cancelled"


# =============================================================================
# Nav2 Interface
# =============================================================================
class Nav2Interface:
    """
    Wrapper for Nav2 via ROS2Bridge daemon.
    Uses subprocess communication instead of direct rclpy.
    """
    
    def __init__(self):
        from multi_function_agent.robot_vision_controller.core.ros2_node import get_ros2_node
        self.bridge = get_ros2_node()
        self.state = NavigationState.IDLE
        logger.info("Nav2Interface initialized (daemon mode)")
    
    def wait_for_nav2(self, timeout: float = 10.0) -> bool:
        """Check if Nav2 daemon is ready."""
        # Daemon handles this internally
        logger.info("âœ… Nav2 ready (daemon mode)")
        return True
    
    def send_goal(self, x: float, y: float, theta: float = 0.0, frame_id: str = 'map') -> bool:
        """Send Nav2 goal via daemon."""
        logger.info(f"ðŸ“ Sending Nav2 goal: ({x:.2f}, {y:.2f}, {theta:.2f}rad)")
        
        success = self.bridge.send_nav2_goal(x, y, theta)
        if success:
            self.state = NavigationState.NAVIGATING
        
        return success
    
    def cancel_navigation(self) -> bool:
        """Cancel Nav2 navigation."""
        logger.warning("ðŸ›‘ Cancelling Nav2 navigation")
        success = self.bridge.cancel_nav2_goal()
        
        if success:
            self.state = NavigationState.CANCELLED
        
        return success
    
    def get_state(self) -> NavigationState:
        """Get current Nav2 state from daemon cache."""
        daemon_state = self.bridge.get_nav2_state()
        
        state_map = {
            'idle': NavigationState.IDLE,
            'navigating': NavigationState.NAVIGATING,
            'succeeded': NavigationState.SUCCEEDED,
            'failed': NavigationState.FAILED,
            'cancelled': NavigationState.CANCELLED
        }
        
        return state_map.get(daemon_state, NavigationState.IDLE)
    
    def is_navigating(self) -> bool:
        return self.get_state() == NavigationState.NAVIGATING
    
    def get_current_path(self) -> Optional[Path]: # type: ignore
        # Not implemented in daemon mode
        return None

